<!DOCTYPE html>
<html lang="en">
<head>
  <script>// polyfills
  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (searchString, position) {
      position = position || 0
      return this.substr(position, searchString.length) === searchString
    }
  }

  ;(function () {
    function s4 () {
      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1)
    }

    var uid = function () {
      return (
        s4() +
        s4() +
        '-' +
        s4() +
        '-' +
        s4() +
        '-' +
        s4() +
        '-' +
        s4() +
        s4() +
        s4()
      )
    }

    function ownKeys (object, enumerableOnly) {
      var keys = Object.keys(object)
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object)
        if (enumerableOnly) {
          symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable
          })
        }
        keys.push.apply(keys, symbols)
      }
      return keys
    }

    function _objectSpread (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}
        if (i % 2) {
          ownKeys(source, true).forEach(function (key) {
            _defineProperty(target, key, source[key])
          })
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(
            target,
            Object.getOwnPropertyDescriptors(source),
          )
        } else {
          ownKeys(source).forEach(function (key) {
            Object.defineProperty(
              target,
              key,
              Object.getOwnPropertyDescriptor(source, key),
            )
          })
        }
      }
      return target
    }

    function _defineProperty (obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true,
        })
      } else {
        obj[key] = value
      }
      return obj
    }

    if (!window.__TAURI__) {
      window.__TAURI__ = {}
    }

    window.__TAURI__.transformCallback = function transformCallback (
      callback,
      once,
    ) {
      var identifier = uid()

      window[identifier] = function (result) {
        if (once) {
          delete window[identifier]
        }

        return callback && callback(result)
      }

      return identifier
    }

    window.__TAURI__.promisified = function promisified (args) {
      var _this = this

      return new Promise(function (resolve, reject) {
        var callback = _this.transformCallback(function (r) {
          resolve(r)
          delete window[error]
        }, true)
        var error = _this.transformCallback(function (e) {
          reject(e)
          delete window[callback]
        }, true)

        window.__TAURI_INVOKE_HANDLER__(
          _objectSpread(
            {
              callback: callback,
              error: error,
            },
            args,
          ),
        )
      })
    }

    window.__TAURI__.loadAsset = function loadAsset (assetName, assetType) {
      return this.promisified({
                                cmd: 'loadAsset',
                                asset: assetName,
                                assetType: assetType || 'unknown',
                              })
    }

    document.addEventListener(
      'error',
      function (e) {
        var target = e.target
        while (target != null) {
          if (
            target.matches
              ? target.matches('img')
              : target.msMatchesSelector('img')
          ) {
            window.__TAURI__.loadAsset(target.src, 'image').then(function (img) {
              target.src = img
            })
            break
          }
          target = target.parentElement
        }
      },
      true,
    )

    // open <a href="..."> links with the Tauri API
    function __openLinks () {
      document.querySelector('body').addEventListener(
        'click',
        function (e) {
          var target = e.target
          while (target != null) {
            if (
              target.matches ? target.matches('a') : target.msMatchesSelector('a')
            ) {
              if (
                target.href &&
                target.href.startsWith('http') &&
                target.target === '_blank'
              ) {
                window.__TAURI_INVOKE_HANDLER__({
                                                  cmd: 'open',
                                                  uri: target.href,
                                                })
                e.preventDefault()
              }
              break
            }
            target = target.parentElement
          }
        },
        true,
      )
    }

    if (
      document.readyState === 'complete' ||
      document.readyState === 'interactive'
    ) {
      __openLinks()
    } else {
      window.addEventListener(
        'DOMContentLoaded',
        function () {
          __openLinks()
        },
        true,
      )
    }

    let permissionSettable = false
    let permissionValue = 'default'

    function isPermissionGranted () {
      if (window.Notification.permission !== 'default') {
        return Promise.resolve(window.Notification.permission === 'granted')
      }
      return window.__TAURI__.promisified({
                                            cmd: 'isNotificationPermissionGranted',
                                          })
    }

    function setNotificationPermission (value) {
      permissionSettable = true
      window.Notification.permission = value
      permissionSettable = false
    }

    function requestPermission () {
      return window.__TAURI__.promisified({
                                            cmd: 'requestNotificationPermission',
                                          }).then(function (permission) {
        setNotificationPermission(permission)
        return permission
      })
    }

    function sendNotification (options) {
      if (typeof options === 'object') {
        Object.freeze(options)
      }

      isPermissionGranted().then(function (permission) {
        if (permission) {
          return window.__TAURI__.promisified({
                                                cmd: 'notification',
                                                options:
                                                  typeof options === 'string'
                                                    ? {
                                                      title: options,
                                                    }
                                                    : options,
                                              })
        }
      })
    }

    window.Notification = function (title, options) {
      var opts = options || {}
      sendNotification(
        Object.assign(opts, {
          title: title,
        }),
      )
    }

    window.Notification.requestPermission = requestPermission

    Object.defineProperty(window.Notification, 'permission', {
      enumerable: true,
      get: function () {
        return permissionValue
      },
      set: function (v) {
        if (!permissionSettable) {
          throw new Error('Readonly property')
        }
        permissionValue = v
      },
    })

    isPermissionGranted().then(function (response) {
      if (response === null) {
        setNotificationPermission('default')
      } else {
        setNotificationPermission(response ? 'granted' : 'denied')
      }
    })

    window.alert = function (message) {
      window.__TAURI_INVOKE_HANDLER__({
                                        cmd: 'messageDialog',
                                        message: message,
                                      })
    }

    window.confirm = function (message) {
      return window.__TAURI__.promisified({
                                            cmd: 'askDialog',
                                            message: message,
                                          })
    }
  })()
  </script>
  <script>// polyfills
  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (searchString, position) {
      position = position || 0
      return this.substr(position, searchString.length) === searchString
    }
  }

  ;(function () {
    function s4 () {
      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1)
    }

    var uid = function () {
      return (
        s4() +
        s4() +
        '-' +
        s4() +
        '-' +
        s4() +
        '-' +
        s4() +
        '-' +
        s4() +
        s4() +
        s4()
      )
    }

    function ownKeys (object, enumerableOnly) {
      var keys = Object.keys(object)
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object)
        if (enumerableOnly) {
          symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable
          })
        }
        keys.push.apply(keys, symbols)
      }
      return keys
    }

    function _objectSpread (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}
        if (i % 2) {
          ownKeys(source, true).forEach(function (key) {
            _defineProperty(target, key, source[key])
          })
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(
            target,
            Object.getOwnPropertyDescriptors(source),
          )
        } else {
          ownKeys(source).forEach(function (key) {
            Object.defineProperty(
              target,
              key,
              Object.getOwnPropertyDescriptor(source, key),
            )
          })
        }
      }
      return target
    }

    function _defineProperty (obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true,
        })
      } else {
        obj[key] = value
      }
      return obj
    }

    if (!window.__TAURI__) {
      window.__TAURI__ = {}
    }

    window.__TAURI__.transformCallback = function transformCallback (
      callback,
      once,
    ) {
      var identifier = uid()

      window[identifier] = function (result) {
        if (once) {
          delete window[identifier]
        }

        return callback && callback(result)
      }

      return identifier
    }

    window.__TAURI__.promisified = function promisified (args) {
      var _this = this

      return new Promise(function (resolve, reject) {
        var callback = _this.transformCallback(function (r) {
          resolve(r)
          delete window[error]
        }, true)
        var error = _this.transformCallback(function (e) {
          reject(e)
          delete window[callback]
        }, true)

        window.__TAURI_INVOKE_HANDLER__(
          _objectSpread(
            {
              callback: callback,
              error: error,
            },
            args,
          ),
        )
      })
    }

    window.__TAURI__.loadAsset = function loadAsset (assetName, assetType) {
      return this.promisified({
                                cmd: 'loadAsset',
                                asset: assetName,
                                assetType: assetType || 'unknown',
                              })
    }

    document.addEventListener(
      'error',
      function (e) {
        var target = e.target
        while (target != null) {
          if (
            target.matches
              ? target.matches('img')
              : target.msMatchesSelector('img')
          ) {
            window.__TAURI__.loadAsset(target.src, 'image').then(function (img) {
              target.src = img
            })
            break
          }
          target = target.parentElement
        }
      },
      true,
    )

    // open <a href="..."> links with the Tauri API
    function __openLinks () {
      document.querySelector('body').addEventListener(
        'click',
        function (e) {
          var target = e.target
          while (target != null) {
            if (
              target.matches ? target.matches('a') : target.msMatchesSelector('a')
            ) {
              if (
                target.href &&
                target.href.startsWith('http') &&
                target.target === '_blank'
              ) {
                window.__TAURI_INVOKE_HANDLER__({
                                                  cmd: 'open',
                                                  uri: target.href,
                                                })
                e.preventDefault()
              }
              break
            }
            target = target.parentElement
          }
        },
        true,
      )
    }

    if (
      document.readyState === 'complete' ||
      document.readyState === 'interactive'
    ) {
      __openLinks()
    } else {
      window.addEventListener(
        'DOMContentLoaded',
        function () {
          __openLinks()
        },
        true,
      )
    }

    let permissionSettable = false
    let permissionValue = 'default'

    function isPermissionGranted () {
      if (window.Notification.permission !== 'default') {
        return Promise.resolve(window.Notification.permission === 'granted')
      }
      return window.__TAURI__.promisified({
                                            cmd: 'isNotificationPermissionGranted',
                                          })
    }

    function setNotificationPermission (value) {
      permissionSettable = true
      window.Notification.permission = value
      permissionSettable = false
    }

    function requestPermission () {
      return window.__TAURI__.promisified({
                                            cmd: 'requestNotificationPermission',
                                          }).then(function (permission) {
        setNotificationPermission(permission)
        return permission
      })
    }

    function sendNotification (options) {
      if (typeof options === 'object') {
        Object.freeze(options)
      }

      isPermissionGranted().then(function (permission) {
        if (permission) {
          return window.__TAURI__.promisified({
                                                cmd: 'notification',
                                                options:
                                                  typeof options === 'string'
                                                    ? {
                                                      title: options,
                                                    }
                                                    : options,
                                              })
        }
      })
    }

    window.Notification = function (title, options) {
      var opts = options || {}
      sendNotification(
        Object.assign(opts, {
          title: title,
        }),
      )
    }

    window.Notification.requestPermission = requestPermission

    Object.defineProperty(window.Notification, 'permission', {
      enumerable: true,
      get: function () {
        return permissionValue
      },
      set: function (v) {
        if (!permissionSettable) {
          throw new Error('Readonly property')
        }
        permissionValue = v
      },
    })

    isPermissionGranted().then(function (response) {
      if (response === null) {
        setNotificationPermission('default')
      } else {
        setNotificationPermission(response ? 'granted' : 'denied')
      }
    })

    window.alert = function (message) {
      window.__TAURI_INVOKE_HANDLER__({
                                        cmd: 'messageDialog',
                                        message: message,
                                      })
    }

    window.confirm = function (message) {
      return window.__TAURI__.promisified({
                                            cmd: 'askDialog',
                                            message: message,
                                          })
    }
  })()</script>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blob Shooter</title>
  <script src="GSAP/gsap.min.js"></script>
  <script src="GSAP/CustomEase.min.js"></script>
  <script>class Enemy {
    constructor (x, y, radius, colour, velocity) {
      this.x = x
      this.y = y
      this.radius = radius
      this.radians = 0
      this.colour = colour
      this.velocity = velocity
      this.center = {
        x,
        y,
      }
      this.type = 'Normal'

      // Special enemies
      if (Math.random() < 0.5) {
        this.type = 'Homing'
        this.colour = this.colour.replace('50%', '75%')

        if (Math.random() < 0.5) {
          this.type = 'Hopping'
          this.colour = this.colour.replace('50%', '25%')
          if (Math.random() < 0.5) {
            this.type = 'Homing-Hopping'
            this.colour = this.colour.replace('25%', '50%')
          }
        }

        if (Math.random() < 0.25) {
          this.type = 'Drunk'
          this.colour = this.colour.replace('50%', '25%')
        }
        this.radius += 10
      }
    }

    draw () {
      ctx.beginPath()
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false)
      ctx.fillStyle = this.colour

      ctx.fill()
    }

    update () {
      this.draw()

      if (this.type === 'Homing') {
        const angle = Math.atan2(player.y - this.y, player.x - this.x)
        this.velocity.x = Math.cos(angle)
        this.velocity.y = Math.sin(angle)

        this.x += this.velocity.x
        this.y += this.velocity.y

      } else if (this.type === 'Hopping' || this.type === 'Drunk') {
        this.radians += 0.1
        if (this.radians >= 2 * Math.PI) {
          this.radians = this.radians %
            (2 * Math.PI)
        }

        this.center.x += this.velocity.x
        this.center.y += this.velocity.y

        if (this.type === 'Drunk') {
          this.x = this.center.x + Math.cos(this.radians) * (15 + this.radius)
          this.y = this.center.y + Math.sin(this.radians) * (15 + this.radius)
        } else if (this.type === 'Hopping') {
          this.x = this.center.x + Math.cos(this.radians) * (5 + this.radius)
          this.y = this.center.y + Math.sin(this.radians) * (5 + this.radius)
        }
      } else if (this.type === 'Homing-Hopping') {
        this.radians += 0.1

        // Overflow protection
        if (this.radians >= 2 * Math.PI) {
          this.radians = this.radians %
            (2 * Math.PI)
        }

        const angle = Math.atan2(player.y - this.center.y,
                                 player.x - this.center.x)
        this.velocity.x = Math.cos(angle)
        this.velocity.y = Math.sin(angle)

        this.center.x += this.velocity.x
        this.center.y += this.velocity.y

        this.x = this.center.x + Math.cos(this.radians) * 10
        this.y = this.center.y + Math.sin(this.radians) * 10
      } else {
        this.x += this.velocity.x
        this.y += this.velocity.y
      }
    }
  }</script>
  <script>class Particle {
    constructor (x, y, radius, colour, velocity) {
      this.x = x
      this.y = y
      this.radius = radius
      this.colour = colour
      this.velocity = velocity
      this.alpha = 1
    }

    draw () {
      ctx.save()
      ctx.globalAlpha = this.alpha
      ctx.beginPath()
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false)
      ctx.fillStyle = this.colour
      ctx.fill()
      ctx.restore()
    }

    update () {
      this.draw()
      this.velocity.x *= friction
      this.velocity.y *= friction
      this.x += this.velocity.x
      this.y += this.velocity.y
      this.alpha -= 0.01
    }
  }</script>
  <script>class Player {
    constructor (x, y, radius, colour) {
      this.x = x
      this.y = y
      this.radius = radius
      this.colour = colour
      this.shootingCooldown = 10
      this.powerUp = ''
      this.damage = projectileSize * 2
      this.velocity = {
        x: 0,
        y: 0,
      }
    }

    draw () {
      ctx.beginPath()
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false)
      ctx.fillStyle = this.colour
      ctx.fill()
    }

    update () {
      this.draw()
      this.shootingCooldown--

      // x boundary
      if (
        this.x + this.radius + this.velocity.x <= canvas.width &&
        this.x - this.radius + this.velocity.x >= 0
      ) {
        this.x += this.velocity.x
      } else {
        this.velocity.x = 0
      }

      // y boundary
      if (
        this.y + this.radius + this.velocity.y <= canvas.height &&
        this.y - this.radius + this.velocity.y >= 0
      ) {
        this.y += this.velocity.y
      } else {
        this.velocity.y = 0
      }

      // friction
      const friction = 0.95

      this.velocity.x *= friction
      this.velocity.y *= friction
    }
  }</script>
  <script>class PowerUp {
    constructor (x, y, velocity) {
      this.x = x
      this.y = y
      this.velocity = velocity
      this.radians = 0

      this.alpha = 1
      gsap.to(this, {
        alpha: 0.1,
        duration: 0.6,
        repeat: -1,
      })

      this.image = new Image()
      this.image.src = './res/img/powerUp.png'
    }

    update () {
      this.draw()
      this.radians += 0.01
      this.x += this.velocity.x
      this.y += this.velocity.y

      // Overflow protection
      if (this.radians >= 2 * Math.PI) {
        this.radians = this.radians %
          (2 * Math.PI)
      }
    }

    draw () {
      ctx.save()
      ctx.globalAlpha = this.alpha
      ctx.translate(this.x + this.image.width / 2, this.y + this.image.height / 2)
      ctx.rotate(this.radians)
      ctx.translate(-this.x - this.image.width / 2,
                    -this.y - this.image.height / 2)
      ctx.drawImage(this.image, this.x, this.y)
      ctx.restore()
    }
  }</script>
  <script>class Projectile {
    constructor (x, y, radius, colour, velocity) {
      this.x = x
      this.y = y
      this.radius = radius
      this.colour = colour
      this.velocity = velocity
    }

    draw () {
      ctx.beginPath()
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false)
      ctx.fillStyle = this.colour
      ctx.fill()
    }

    update () {
      this.draw()
      this.x += this.velocity.x
      this.y += this.velocity.y
    }
  }</script>
  <script defer="">// init DOM elements

  const canvas = document.getElementById('canvas')
  const ctx = canvas.getContext('2d')
  const startGameBtn = document.getElementById('start')
  const menu = document.getElementById('menu')
  const scoreEl = document.getElementById('score')
  const endScore = document.getElementById('bigScore')
  const endHighScore = document.getElementById('highScore')
  // tweaking canvas

  canvas.width = innerWidth
  canvas.height = innerHeight
  // define commonly used value

  const canvasCenter = {
    x: canvas.width / 2,
    y: canvas.height / 2,
  }
  // define vars and constants

  const friction = 0.99
  let score = 0
  let highScore = localStorage.getItem('highScore') === null
    ? localStorage.setItem('highScore', score.toString())
    : localStorage.getItem('highScore')
  endHighScore.innerHTML = highScore
  let projectiles
  let particles
  let enemies
  let start = false
  let mouseX
  let mouseY
  let mouseDown
  let projectileSize = 5
  let powerUps = []
  const maxEnemySize = 30
  const minEnemySize = 5
  const randomPos = {
    x: Math.random() * canvasCenter.x,
    y: Math.random() * canvasCenter.y,
  }

  const player = new Player(canvasCenter.x, canvasCenter.y, 10, 'white')

  projectiles = []
  particles = []
  enemies = []
  let enemyInterval, powerUpInterval

  function init () {
    score = 0
    scoreEl.innerHTML = score
    projectiles = []
    particles = []
    enemies = []
    powerUps = []
    start = true
    player.x = canvasCenter.x
    player.velocity.x = 0
    player.y = canvasCenter.y
    player.velocity.y = 0
    clearInterval(enemyInterval)
    clearInterval(powerUpInterval)
  }

  function spawnEnemies () {
    enemyInterval = setInterval(() => {
      const radius = Math.random() * (maxEnemySize - minEnemySize) + minEnemySize
      let pos = spawnOnEdge(radius, radius)
      const angle = Math.atan2(canvasCenter.y - pos.y, canvasCenter.x - pos.x)
      const velocity = {
        x: Math.cos(angle),
        y: Math.sin(angle),
      }
      const colour = `hsl(${Math.random() * 360}, 50%, 50%)`
      enemies.push(new Enemy(pos.x, pos.y, radius, colour, velocity))
    }, Math.random() * (2000 - 800) + 800)
  }

  function spawnPowerUps () {
    powerUpInterval = setInterval(() => {
      let pos = spawnOnEdge(16, 16) // Width and height of image
      const angle = Math.atan2(randomPos.y - pos.y, randomPos.x - pos.x)
      const velocity = {
        x: Math.cos(angle),
        y: Math.sin(angle),
      }
      powerUps.push(new PowerUp(pos.x, pos.y, velocity))
    }, Math.random() * (60000 - 40000) + 40000)
  }

  function spawnOnEdge (width, height) {
    let x, y
    if (Math.random() < 0.5) {
      x = Math.random() < 0.5 ? 0 - width : canvas.width + width
      y = Math.random() * canvas.height
    } else {
      x = Math.random() * canvas.width
      y = Math.random() < 0.5 ? 0 - height : canvas.height + height
    }

    return { x: x, y: y }
  }

  function resetHighScore () {
    if (confirm('Reset HighScore to 0?\nThis action CANNOT be undone.')) {
      highScore = 0
      endHighScore.innerHTML = highScore
      localStorage.setItem('highScore', highScore)
    }
  }

  let animationID

  function animate () {
    animationID = requestAnimationFrame(animate)
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'
    ctx.fillRect(0, 0, canvas.width, canvas.height)

    player.update()

    powerUps.forEach((powerUp, pIndex) => {
      powerUp.update()

      const dist = Math.hypot(
        player.x - powerUp.x,
        player.y - powerUp.y,
      )

      // Gain powerUp
      if (dist < powerUp.image.height / 2 + player.radius) {
        powerUps.splice(pIndex, 1)
        player.powerUp = 'machine gun'
        setTimeout(() => {
          player.powerUp = ''
        }, 20000)
      }
    })

    // Machine gun implementation
    if (player.powerUp === 'machine gun') {
      if (player.shootingCooldown <= 0) {
        if (mouseDown) {
          shootMachineGun()
          player.shootingCooldown = 4
        }
      }
    }

    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false)
    particles.forEach((particle, index) => {
      if (particle.alpha <= 0) {
        setTimeout(() => {
          particles.splice(index, 1)
        }, 0)
      } else {
        particle.update()
      }
    })

    projectiles.forEach((projectile, pIndex) => {
      projectile.update()

      // remove off-screen projectiles
      if (
        projectile.x + projectile.radius < 0 ||
        projectile.x - projectile.radius > canvas.width ||
        projectile.y + projectile.radius < 0 ||
        projectile.y - projectile.radius > canvas.height
      ) {
        setTimeout(() => {
          projectiles.splice(pIndex, 1)
        }, 0)
      }
    })

    enemies.forEach((enemy, eIndex) => {
      enemy.update()

      const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y)

      // Dead, end the game
      if (dist - enemy.radius - player.radius < 1) {
        start = false
        cancelAnimationFrame(animationID)
        endScore.innerHTML = score
        endHighScore.innerHTML = highScore
        menu.style.display = 'flex'
        gsap.fromTo(
          '#menu',
          {
            opacity: 0,
            scale: 0.7,
          },
          {
            opacity: 1,
            scale: 1,
            duration: 0.4,
            ease: 'expo',
          },
        )
        startGameBtn.innerHTML = 'Restart'
        addEventListener('keydown', startGameBind)
      }

      projectiles.forEach((projectile, playerIndex) => {
        const dist = Math.hypot(projectile.x - enemy.x, projectile.y - enemy.y)
        // Enemy damaged

        if (dist - enemy.radius - projectile.radius < 1) {
          // Spawn particles

          for (let i = 0; i < enemy.radius * 2; i++) {
            particles.push(
              new Particle(
                projectile.x,
                projectile.y,
                Math.random() * 3,
                enemy.colour,
                {
                  x: (Math.random() - 0.5) * (Math.random() * 5),
                  y: (Math.random() - 0.5) * (Math.random() * 5),
                },
              ),
            )
          }
          // add to score

          score += Math.ceil(enemy.radius / 5)
          if (score > localStorage.getItem('highScore')) {
            localStorage.setItem('highScore', score)
            highScore = score
          }
          scoreEl.innerHTML = score

          if (enemy.radius - player.damage > player.damage) {
            gsap.to(enemy, { radius: enemy.radius - player.damage })
            projectiles.splice(playerIndex, 1)
          } else {
            // Enemy dead

            setTimeout(() => {
              enemies.splice(eIndex, 1)
              projectiles.splice(playerIndex, 1)
            }, 0)

            scoreEl.innerHTML = score
          }
        }
      })
    })
  }

  function shoot (x, y) {
    if (start) {
      if (projectiles.length <= 700) {
        const angle = Math.atan2(
          y - player.y,
          x - player.x,
        )
        const velocity = {
          x: Math.cos(angle) * 5,
          y: Math.sin(angle) * 5,
        }

        projectiles.push(
          new Projectile(player.x, player.y, projectileSize, 'white', velocity))
      }
    }
  }

  function shootMachineGun () {
    if (start) {
      if (projectiles.length <= 700) {
        const angle = Math.atan2(
          mouseY - player.y,
          mouseX - player.x,
        )
        const velocity = {
          x: Math.cos(angle) * 5,
          y: Math.sin(angle) * 5,
        }

        projectiles.push(
          new Projectile(player.x, player.y, projectileSize, 'yellow', velocity))
      }
    }
  }</script>
  <script defer="">// shoot
  addEventListener('click', (event) => {
    if (player.powerUp !== 'machine gun') {
      if (player.shootingCooldown <= 0) {
        shoot(event.clientX, event.clientY)
        player.shootingCooldown = 6
      }
    }
  })

  addEventListener('mousedown', () => {
    mouseDown = true
  })

  addEventListener('mouseup', () => {
    mouseDown = false
  })

  // start game button actions and animations

  function startGame () {
    setTimeout(() => {
      init()
      animate()

      spawnEnemies()
      spawnPowerUps()
      gsap.to('#menu', {
        opacity: 0,
        scale: 0.7,
        duration: 0.4,
        ease: 'expo.in',
        onComplete: () => {
          menu.style.display = 'none'
        },
      })
    }, 50)
  }

  const startGameOnEnter = function (event) {
    if (event.key === 'Enter') {
      startGame()
      removeEventListener('keydown', startGameBind)
    }
  }

  const startGameBind = startGameOnEnter.bind(KeyboardEvent)

  startGameBtn.addEventListener('click', startGame)
  addEventListener('keydown', startGameBind)

  addEventListener('keydown', (e) => {
    switch (e.key) {
      case 'w':
      case 'ArrowUp':
        player.velocity.y -= 1
        break
      case 'a':
      case 'ArrowLeft':
        player.velocity.x -= 1
        break
      case 's':
      case 'ArrowDown':
        player.velocity.y += 1
        break
      case 'd':
      case 'ArrowRight':
        player.velocity.x += 1
        break
    }
  })

  addEventListener('mousemove', (event) => {
    mouseX = event.clientX // Gets Mouse X
    mouseY = event.clientY // Gets Mouse Y
  })</script>
  <style>* {
      font-family: system-ui;
  }

  body {
      margin: 0;
      overflow: hidden;
  }

  canvas {
      background-color: black;
  }

  h1, p, a {
      margin: 0;
  }

  p, a {
      margin-bottom: 1rem;
  }

  h1 {
      font-size: 300%;
      font-weight: bold;
      line-height: 1;
  }

  a {
      color: gray;
  }

  button {
      font-size: large;
      background-color: rgb(59 130 246);
      width: 100%;
      padding: 0.75rem 10px;
      color: white;
      border-radius: 10px;
  }

  .label {
      font-size: 75%;
      color: gray;
  }

  *, ::before, ::after {
      border-width: 0;
      border-style: solid;
  }

  .scoreboard {
      user-select: none;
      margin-left: 10px;
      margin-top: 5px;
      position: fixed;
      color: white;
  }

  .float {
      user-select: none;
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      align-items: center;
  }

  .background {
      background-color: white;
      max-width: 28rem;
      padding: 6%;
      width: 100%;
      text-align: center;
      border-radius: 10px;
  }</style>
  <meta http-equiv="Content-Security-Policy"
        content="default-src blob: data: filesystem: ws: http: https: 'unsafe-eval' 'unsafe-inline'">
  <meta http-equiv="Content-Security-Policy"
        content="default-src blob: data: filesystem: ws: http: https: 'unsafe-eval' 'unsafe-inline'">
</head>
<body>
<div class="scoreboard"><p>Score: <span id="score">0</span></p></div>
<div class="float" id="menu">
  <div class="background"><h1 id="bigScore">0</h1>
    <p class="label">Points</p>
    <h1 id="highScore">0</h1>
    <p class="label">Highest Score <a href="javascript:resetHighScore()">Reset</a></p>
    <div>
      <button id="start">Start Game</button>
    </div>
  </div>
</div>
<canvas id="canvas" width="500" height="500"></canvas>
</body>
</html>